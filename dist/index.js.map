{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"2gBAAA,4B,wVAEA,GAAM,aAAc,QAAd,YAAc,cAAS,QAAS,MAAM,KAAf,EAAwB,MAAM,KAAN,CAAY,QAA7C,CAApB,CACA,GAAM,oBAAqB,QAArB,mBAAqB,cAAS,aAAY,KAAZ,GAAsB,QAAO,MAAM,KAAN,CAAY,QAAnB,IAAgC,QAA/D,CAA3B,C,6CAYE,M,iBAAO,Q,CAAU,Q,CAAU,CACzB,MAAO,iBACJ,OADI,CACI,QADJ,EAEJ,MAFI,CAEG,QAFH,CAGR,C,CAOD,U,qBAAW,Q,CAAU,Y,CAAc,gBACjC,MAAO,iBACJ,OADI,CACI,QADJ,EAEJ,MAFI,CAEG,YAFH,EAGJ,GAHI,CAGA,SAAC,KAAD,CAAW,CACd,GAAI,mBAAmB,KAAnB,CAAJ,CAA+B,CAE7B,MAAO,wBAAa,KAAb,aACF,MAAM,KADJ,EAEL,SAAU,MAAK,UAAL,CAAgB,MAAM,KAAN,CAAY,QAA5B,CAAsC,YAAtC,CAFL,GAIR,CACD,MAAO,MACR,CAZI,CAaR,C,CAUD,W,sBAAY,Q,CAAU,K,CAAO,I,CAAM,CACjC,MAAO,iBACJ,OADI,CACI,QADJ,EAEJ,MAFI,CAEG,SAAC,KAAD,CAAQ,KAAR,CAAkB,CACxB,GAAM,WAAY,MAAM,QAAN,CAAe,MAAM,IAArB,CAAlB,CACA,GAAM,UAAW,UAAY,MAAM,KAAN,CAAY,QAAxB,CAAmC,KAApD,CACA,GAAM,KAAM,UAAY,MAAM,IAAlB,CAAyB,IAArC,CAEA,mBACK,KADL,oBAEG,GAFH,8BAEc,MAAM,GAAN,GAAc,EAF5B,GAEiC,QAFjC,IAID,CAXI,CAWF,EAXE,CAYR,C,CAQD,O,kBAAQ,Q,CAAU,S,CAAW,iBAC3B,MAAO,iBACJ,GADI,CACA,QADA,CACU,SAAC,KAAD,CAAW,CACxB,GAAI,mBAAmB,KAAnB,CAAJ,CAA+B,CAE7B,MAAO,WAAU,wBAAa,KAAb,aACZ,MAAM,KADM,EAEf,SAAU,OAAK,OAAL,CAAa,MAAM,KAAN,CAAY,QAAzB,CAAmC,SAAnC,CAFK,GAAV,CAIR,CACD,MAAO,WAAU,KAAV,CACR,CAVI,CAWR,C,CAOD,W,sBAAY,Q,CAAU,a,CAAe,iBACnC,gBACG,OADH,CACW,QADX,CACqB,SAAC,KAAD,CAAW,CAC5B,GAAI,mBAAmB,KAAnB,CAAJ,CAA+B,CAE7B,OAAK,WAAL,CAAiB,MAAM,KAAN,CAAY,QAA7B,CAAuC,aAAvC,CACD,CACD,cAAc,KAAd,CACD,CAPH,CAQD,C,CAQD,Q,mBAAS,Q,CAAU,U,CAAY,iBAC7B,MAAO,iBACJ,OADI,CACI,QADJ,EAEJ,IAFI,CAEC,SAAC,KAAD,CAAW,CACf,GAAI,mBAAmB,KAAnB,CAAJ,CAA+B,CAE7B,MAAO,QAAK,QAAL,CAAc,MAAM,KAAN,CAAY,QAA1B,CAAoC,UAApC,CACR,CACD,MAAO,YAAW,KAAX,CACR,CARI,CASR,C,CAOD,Q,mBAAS,Q,CAAU,iBACjB,MAAO,iBACJ,OADI,CACI,QADJ,EAEJ,MAFI,CAEG,SAAC,SAAD,CAAY,KAAZ,qCACH,SADG,GAEN,YAAY,KAAZ,EAAqB,OAAK,QAAL,CAAc,MAAM,KAAN,CAAY,QAA1B,CAArB,CAA2D,KAFrD,GAFH,CAKF,EALE,EAMJ,IANI,CAMC,EAND,CAOR,C","file":"index.js","sourcesContent":["import { Children, cloneElement } from 'react';\n\nconst hasChildren = child => child && child.props && child.props.children;\nconst hasComplexChildren = child => hasChildren(child) && typeof child.props.children === 'object';\n\nexport default {\n\n  ...Children,\n\n  /**\n   * Filter children\n   * @param   {object} children - React component children\n   * @param {function} filterFn - Array filter callback\n   * @returns  {array}          - Filtered children\n   */\n  filter(children, filterFn) {\n    return Children\n      .toArray(children)\n      .filter(filterFn);\n  },\n\n  /**\n   * Filter children and its children\n   * @param   {object} children     - React component children\n   * @param {function} deepFilterFn - Deep Filter callback\n   */\n  deepFilter(children, deepFilterFn) {\n    return Children\n      .toArray(children)\n      .filter(deepFilterFn)\n      .map((child) => {\n        if (hasComplexChildren(child)) {\n          // Clone the child that has children and filter them too\n          return cloneElement(child, {\n            ...child.props,\n            children: this.deepFilter(child.props.children, deepFilterFn),\n          });\n        }\n        return child;\n      });\n  },\n\n  /**\n   * Group children by type and puts in a rest key\n   * the types not indicated\n   * @param   {object} children - React component children\n   * @param {string[]} types    - Array of child types\n   * @param   {string} rest     - Object key name where non types will be saved\n   * @returns {object}          - Map of the types and rest\n   */\n  groupByType(children, types, rest) {\n    return Children\n      .toArray(children)\n      .reduce((group, child) => {\n        const isGrouped = types.includes(child.type);\n        const addChild = isGrouped ? child.props.children : child;\n        const key = isGrouped ? child.type : rest;\n\n        return {\n          ...group,\n          [key]: [...(group[key] || []), addChild],\n        };\n      }, {});\n  },\n\n  /**\n   * Map children and its children\n   * @param   {object} children  - React component children\n   * @param {function} deepMapFn - Deep Map callback\n   * @returns  {array}           - Deep Mapped children\n   */\n  deepMap(children, deepMapFn) {\n    return Children\n      .map(children, (child) => {\n        if (hasComplexChildren(child)) {\n          // Clone the child that has children and map them too\n          return deepMapFn(cloneElement(child, {\n            ...child.props,\n            children: this.deepMap(child.props.children, deepMapFn),\n          }));\n        }\n        return deepMapFn(child);\n      });\n  },\n\n  /**\n   * ForEach children and its children\n   * @param   {object} children      - React component children\n   * @param {function} deepForEachFn - Deep Map callback\n   */\n  deepForEach(children, deepForEachFn) {\n    Children\n      .forEach(children, (child) => {\n        if (hasComplexChildren(child)) {\n          // Each inside the child that has children\n          this.deepForEach(child.props.children, deepForEachFn);\n        }\n        deepForEachFn(child);\n      });\n  },\n\n  /**\n   * Find in children and its children\n   * @param   {object} children   - React component children\n   * @param {function} deepFindFn - Deep Map callback\n   * @returns  {array}            - Children found\n   */\n  deepFind(children, deepFindFn) {\n    return Children\n      .toArray(children)\n      .find((child) => {\n        if (hasComplexChildren(child)) {\n          // Find inside the child that has children\n          return this.deepFind(child.props.children, deepFindFn);\n        }\n        return deepFindFn(child);\n      });\n  },\n\n  /**\n   * Get only the text in children and its children\n   * @param   {object} children - React component children\n   * @returns  {string}         - Text of all children\n   */\n  onlyText(children) {\n    return Children\n      .toArray(children)\n      .reduce((flattened, child) => [\n        ...flattened,\n        hasChildren(child) ? this.onlyText(child.props.children) : child,\n      ], [])\n      .join('');\n  },\n};\n"]}